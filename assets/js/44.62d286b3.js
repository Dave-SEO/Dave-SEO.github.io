(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{609:function(t,s,r){"use strict";r.r(s);var a=r(3),p=Object(a.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"信道复用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#信道复用"}},[t._v("#")]),t._v(" 信道复用")]),t._v(" "),r("h1",{attrs:{id:"分帧传输"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分帧传输"}},[t._v("#")]),t._v(" 分帧传输")]),t._v(" "),r("ol",[r("li",[t._v("http2的分帧传输，在同一个连接上面可以并发的发送不同的请求")]),t._v(" "),r("li",[t._v("传输的一个http数据并不需要一定按照连续的顺序进行发送，而是可以分成不同的帧，然后一起进行发送，如果中间部分先到服务器也没关系，最后会把数据接收完之后，根据一个帧信息里面包含的先后顺序，在进行组合，拿到一个真正的数据")])]),t._v(" "),r("h1",{attrs:{id:"server-push"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#server-push"}},[t._v("#")]),t._v(" server push")]),t._v(" "),r("ol",[r("li",[t._v("传统的http1.1中客户端是主动的，服务端是被动的")]),t._v(" "),r("li",[t._v("在http1.1中如果一个页面加载过来有很多资源，比如图片，css，js 这些请求是并发的去发送，并发的过程中需要创建并发的http连接，浏览器有并发限制，像Chrome中只有6个，如果一次并发超过6个剩下的一些需要等待前6个拿到服务器的返回之后，才能继续发送请求，所以这个时候就会变成相对串行的操作，效率就不是很高")]),t._v(" "),r("li",[t._v("建立不同的连接，如果有一起创建6个tcp连接，需要进行tcp的6次三次握手，创建连接的开销是比较大的，同时对于一个服务器来讲，他可以创建的tcp连接数是有一个上限的，所以每次都创建6个tcp连接，会导致服务器的tcp连接数很快的消耗完，所以在http1.1中受到很大的制约")])]),t._v(" "),r("h1",{attrs:{id:"为什么不能在一个tcp连接上面去发送请求呢"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么不能在一个tcp连接上面去发送请求呢"}},[t._v("#")]),t._v(" 为什么不能在一个tcp连接上面去发送请求呢？")]),t._v(" "),r("ol",[r("li",[t._v("在http1.1中发送请求，在tcp连接上发送数据是必须要发送完一个请求后，在发送第二个请求，同时服务端返回也是要把前一个请求的数据全部返回之后，才能返回第二个数据，也就是第一个数据请求特别慢，第二个请求比他先执行完成，但还是会等第一个请求执行完成，才能返回，所以如果复用一个tcp连接，在http1.1中，其实是一个串行的过程，而不是一个并行的过程，所以效率比较低")]),t._v(" "),r("li",[t._v("在http2中得意于信道复用和分帧传输的好处，所以网站开启http2之后我们每个用户访问我们的网站他永远只需要创建一个tcp连接，因为在这个tcp连接上面，我们完全可以并发的发送，并发的返回，没有一个阻塞的过程，同时服务端还可以根据需求主动的响应用户推送一些消息")]),t._v(" "),r("li",[t._v("http2是由谷歌之前开发的spdy的一个协议演化而来的，spdy需要使用https，所以目前仅支持https")])])])}),[],!1,null,null,null);s.default=p.exports}}]);
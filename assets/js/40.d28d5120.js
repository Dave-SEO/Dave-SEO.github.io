(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{602:function(t,a,s){"use strict";s.r(a);var e=s(3),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h5",{attrs:{id:"版本控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#版本控制"}},[t._v("#")]),t._v(" 版本控制")]),t._v(" "),s("h6",{attrs:{id:"中央版本控制系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#中央版本控制系统"}},[t._v("#")]),t._v(" 中央版本控制系统")]),t._v(" "),s("ol",[s("li",[t._v("中央版本控制系统必须存在两个端，服务端和客户端，当进行代码备份时，客户端会向服务端发出请求，并将此次修改的内容发送到服务器当中去，服务端收到请求后，会将代码存储到服务器当中，同样当客户端想查看某一个版本的修改内容或者想恢复到某一个版本时，客户端也会发送请求到服务端，服务端再与之相应的响应\n{% asset_img 1-1.png gitpage %}\n从图中可以看到当提交代码时候，两个客户端都是把数据推送服务器当中去，拉取的时候代码也都是从服务器中获取，可以看出这是非常典型的 C/S 机制；张三和李四的交互都必须通过中央服务器，不能私下直接访问。")])]),t._v(" "),s("h6",{attrs:{id:"分布式版本控制系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式版本控制系统"}},[t._v("#")]),t._v(" 分布式版本控制系统")]),t._v(" "),s("ol",[s("li",[t._v("分布式版本控制器，主要是将备份的代码以及记录完全独立在本地存储，比如说上面提到，当你想将代码恢复到某一个版本的时候，本地版本控制器，不需要依赖网络便可以完成此操作，因为本地版本控制器拥有完整独立的控制系统。\n{% asset_img 1-1.png gitpage %}")]),t._v(" "),s("li",[t._v("从图中可以看出，张三和李四不仅仅可以向服务器推送代码，服务器也可以向客户端推送代码；并且张三和李四还可以互相推送代码，同样拉取代码也可以从任意一个节点中拉取，而不必须从服务器中拉取。所以从分布式版本控制系统本身的功能来说，它们是完全平等的，每一个系统都拥有全部的功能；但在实际的工作中我们为了更好地管理代码版本，会人为设置一些规则来限制代码推送，所以在图中的红色线条通常是不会使用的，另外服务端通常也不会去主动向客户端推送和拉取代码。")])]),t._v(" "),s("h6",{attrs:{id:"git和svn"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git和svn"}},[t._v("#")]),t._v(" git和svn")]),t._v(" "),s("ol",[s("li",[t._v("目前主流的版本控制系统主要有git和svn，各自分别代表分布式版本控制系统和中央版本控制系统，两个工具各有优势。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);